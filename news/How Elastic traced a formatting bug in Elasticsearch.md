
> Source : https://www.elastic.co/kr/blog/how-elastic-traced-a-formatting-bug-in-elasticsearch

## 개요

새로운 기능을 추가하는 것은 정말 재미있지만 버그를 고치는 작업은 강건하고 신뢰있는 플랫폼을 만들기 위한 중요한 작업 중 하나이다.  
우리도 자잘한 버그들을 자주 발생시키고 전혀 예상하지 못했던 곳에서 버그가 발생하는 경우도 있다  
이 글은 테스트 케이스가 희소하게 실패하는 경우를 따라가서 Java가 datetime 포맷을 다루는 방식에서 실제 버그를 발견하게 된 방법에 대한 이야기다.

## How we got here

Elasticsearch(이하 ES)에는 집계 결과를 페이징하는데 사용할 수 있는 composite aggregation 기능이 있다.  
해당 기능은 호출 시 응답으로 "after key"를 포함한다. 이는 사람이 읽을 수 있는 반환딘 마지막 버킷을 나타낸다.  
호출자는 반환 된 after key를 다음 호출에 전달하여 마지막 지점 이후에서부터 집계 결과를 선택할 수 있다.  
사람이 읽을 수 있게 키를 구성한 점은 디버깅 과정에서 많은 도움이 된다. 하지만 키를 어떤 포맷으로 구성할지 결정해야한다.

그런데 우리는 composite aggregation이 stuck되는 이상한 버그가 보고되었다.  
간단하게 요약하면 호출자가 after key로 새로운 페이지를 전달받는데 이미 전달받은 동일한 페이지를 응답받는다.  
....? 뭐가 문제일까?

확인해보니 날짜 형식이 문제였다.  
일부 날짜 형식이 올바르게 왕복되지 않은 것으로 확인되었다.  
즉, 포맷팅된 문자열이 다시 원래 값으로 파싱되지 않게되었다.  
언뜻 보면 모든 형식이 올바르게 왕복(포맷팅, 언포맷팅 과정을 의미하는 듯)할 수 있어야 될 것 같지만 실제로는 그렇지 않았다  
예를 듦면 호출자는 YYYY-MM-dd 포맷을 사용했다. 이는 week-based-year를 나타내며, yyyy 를 사용하면 month-based-year를 나타낸다.  
이는 파싱할 때 문제를 일으키게 되는데 예를들어 2020-12-31은 2020년의 53번 째 주로 봐야할지 2021년의 1번 째 주로 봐야할지의 문제와 같다  
이런 선택지 중에서 선택할 수 없는 상황에 내부적으로 파싱 과정에서 기본값 1로 설정한다. 그래서 우리는 항상 1월 1일을 되돌려 받게 되었다  
참조 : https://nidev.gitlab.io/2021/01/01/2020%EB%85%84-12%EC%9B%94-30%EC%9D%BC%EC%9D%80-%EB%AA%87%EB%B2%88%EC%A7%B8-%EC%A3%BC%EC%9D%B8%EA%B0%80-feat-Java/

...


2020-53 = 2020년의 마지막 주 = 2021년의 첫번째 주

